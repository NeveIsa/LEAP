<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>LoopLab • Quiz</title>
  <link rel="stylesheet" href="style/app.css" />
  <style>
    .q{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:16px}
    .q h3{margin:0 0 8px 0}
    .choices{display:grid;gap:8px}
    .row{display:flex;gap:8px;align-items:center}
    .row .spacer{flex:1}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <a class="link" href="dashboard.html">← Back</a>
      <div class="spacer"></div>
      <span id="active" class="badge">Active: …</span>
    </div>

    <div class="card" style="margin-bottom:12px">
      <div class="grid" style="grid-template-columns:repeat(auto-fit,minmax(220px,1fr))">
        <div class="field"><label>Student ID</label><input id="sid" class="input" placeholder="e.g. s001"></div>
        <div class="field"><label>Trial (optional)</label><input id="trial" class="input" placeholder="e.g. quiz-01"></div>
        <div class="field"><label>&nbsp;</label><span id="reg" class="pill">—</span></div>
      </div>
      <div class="msg">Answers are logged immediately when you submit.</div>
    </div>

    <div class="card" style="margin-bottom:12px">
      <div class="row">
        <button id="statsBtn" class="btn">Show Answer Statistics</button>
        <span id="statsStatus" class="msg" style="margin-left:10px;"></span>
        <div class="spacer"></div>
        <label class="row" style="gap:6px; font-size: 0.9em; opacity: 0.9">
          <input id="dedupe" type="checkbox" checked>
          <span>Deduplicate by student (latest)</span>
        </label>
      </div>
    </div>

    <div id="qs" class="stack"></div>
    <div id="statsPanel" class="card" style="margin-top:12px; display:none"></div>
  </div>

  <script>
    const origin = location.origin; const m = location.pathname.match(/\/exp\/([^\/]+)/); const exp = m? m[1]: null;
    (async()=>{ try{ const r=await fetch(`${origin}/api/active-experiment`); const d=await r.json(); document.getElementById('active').textContent = `Active: ${d.active || 'none'}`; }catch{} })();
    const qsEl = document.getElementById('qs');
    const sidEl = document.getElementById('sid');
    const trialEl = document.getElementById('trial');
    const regEl = document.getElementById('reg');
    const api = (p)=> `${origin}${p}`;
    const statsBtn = document.getElementById('statsBtn');
    const statsStatus = document.getElementById('statsStatus');
    const statsPanel = document.getElementById('statsPanel');
    const dedupeEl = document.getElementById('dedupe');

    // Persist student id
    sidEl.value = localStorage.getItem('looplab.quiz.sid') || '';
    sidEl.addEventListener('input', ()=> localStorage.setItem('looplab.quiz.sid', sidEl.value.trim()));
    trialEl.value = localStorage.getItem('looplab.quiz.trial') || '';
    trialEl.addEventListener('input', ()=> localStorage.setItem('looplab.quiz.trial', trialEl.value.trim()));

    // Registration status is experiment-scoped and may require admin; show unknown and rely on submit error if not registered.
    regEl.textContent = 'unknown';

    let QUESTIONS = [];

    // Parse markdown questions
    async function loadQuestions() {
      console.log('loadQuestions() called');
      try {
        console.log('Fetching questions.md...');
        const response = await fetch('questions.md');
        console.log('Response status:', response.status, response.ok);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const markdown = await response.text();
        console.log('Received markdown, length:', markdown.length);
        console.log('First 200 chars of markdown:', markdown.substring(0, 200));
        
        QUESTIONS = parseMarkdownQuestions(markdown);
        console.log('Final QUESTIONS array length:', QUESTIONS.length);
      } catch (error) {
        console.error('Failed to load questions:', error);
        console.log('Using fallback hardcoded questions');
        // Fallback to hardcoded questions
        QUESTIONS = [
          { id: 'q1', text: 'Which method finds roots by halving intervals?', choices: [ 'Newton-Raphson', 'Secant', 'Bisection', 'Fixed-point' ], correct: 2 },
          { id: 'q2', text: 'Derivative of x^2 is:', choices: [ 'x', '2x', 'x^3', 'constant' ], correct: 1 },
          { id: 'q3', text: 'Matrix multiplication A(m×n)·B(n×p) yields shape:', choices: [ 'm×n', 'n×p', 'm×p', 'p×m' ], correct: 2 },
        ];
      }
    }

    function parseMarkdownQuestions(markdown) {
      const questions = [];
      // Split by question headers - capture both question number and ID
      const sections = markdown.split(/^## Question \d+: (\w+)/m);
      
      console.log('Split into', sections.length, 'sections');
      
      // Process each section (sections[0] is the content before first question)
      for (let i = 1; i < sections.length; i += 2) {
        const id = sections[i]; // The captured ID (q1, q2, etc.)
        const content = sections[i + 1]; // The content after the ID
        
        console.log('Processing question ID:', id);
        if (!content) {
          console.log('No content for', id);
          continue;
        }
        
        const lines = content.trim().split('\n');
        
        // Find question text (bold text)
        let text = '';
        for (const line of lines) {
          const match = line.match(/\*\*(.*?)\*\*/);
          if (match) {
            text = match[1];
            break;
          }
        }
        
        console.log('Question text for', id, ':', text);
        if (!text) continue;
        
        // Extract choices and find correct answer
        const choices = [];
        let correct = -1;
        
        lines.forEach((line, lineIdx) => {
          // Match A) B) C) D) patterns with optional checkmark
          const choiceMatch = line.match(/^[A-Z]\)\s*(.*?)$/);
          if (choiceMatch) {
            let choiceText = choiceMatch[1].trim();
            const hasCheckmark = choiceText.includes('✓');
            
            // Remove checkmark from choice text
            if (hasCheckmark) {
              choiceText = choiceText.replace(/\s*✓\s*$/, '').trim();
              correct = choices.length; // This will be the index after we push
            }
            
            choices.push(choiceText);
            console.log(`Choice ${choices.length}: "${choiceText}" ${hasCheckmark ? '(CORRECT)' : ''}`);
          }
        });
        
        console.log(`Question ${id}: ${choices.length} choices, correct=${correct}`);
        
        if (choices.length > 0 && correct >= 0) {
          questions.push({ id, text, choices, correct });
          console.log(`Added question ${id}`);
        }
      }
      
      console.log(`Parsed ${questions.length} questions from markdown`);
      return questions;
    }

    function render(){
      console.log('render() called with', QUESTIONS.length, 'questions');
      qsEl.innerHTML='';
      
      if (QUESTIONS.length === 0) {
        qsEl.innerHTML = '<div style="text-align:center;padding:20px;color:orange;">No questions loaded! Check console for errors.</div>';
        return;
      }
      
      QUESTIONS.forEach((q, idx)=>{
        console.log('Rendering question', idx+1, ':', q.text);
        const wrap = document.createElement('div'); wrap.className='q';
        const title = document.createElement('h3'); title.textContent = `${idx+1}. ${q.text}`; wrap.appendChild(title);
        const choices = document.createElement('div'); choices.className='choices';
        q.choices.forEach((c, i)=>{
          const id = `${q.id}_${i}`;
          const label = document.createElement('label'); label.className='row';
          label.innerHTML = `<input type="radio" name="${q.id}" value="${i}"> <span>${c}</span>`;
          choices.appendChild(label);
        });
        wrap.appendChild(choices);
        const row = document.createElement('div'); row.className='row'; row.style.marginTop='10px';
        const btn = document.createElement('button'); btn.className='btn'; btn.textContent='Submit';
        const msg = document.createElement('span'); msg.className='msg'; msg.textContent='';
        row.appendChild(btn); row.appendChild(msg); wrap.appendChild(row);

        btn.onclick = async ()=>{
          const sid = sidEl.value.trim(); const trial = trialEl.value.trim();
          if(!sid){ msg.textContent='Enter Student ID'; msg.className='msg err'; return; }
          const sel = wrap.querySelector(`input[name="${q.id}"]:checked`);
          if(!sel){ msg.textContent='Select an option'; msg.className='msg err'; return; }
          const choiceIdx = Number(sel.value);
          const payload = { kind:'quiz', qid:q.id, question:q.text, choice_index: choiceIdx, choice_text: q.choices[choiceIdx], ts: new Date().toISOString() };
          try{
            // Root /call requires experiment_name; verify against active
            let experiment_name = '';
            try { const r = await fetch(`${origin}/api/active-experiment`); if (r.ok) { const d = await r.json(); experiment_name = d.active || ''; } } catch {}
            const res = await fetch(`${origin}/call`,{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ student_id: sid, func_name: 'echo', args: [payload], trial: trial || undefined, experiment_name })});
            if(!res.ok){ let t=''; try{ const d = await res.json(); t = typeof d.detail==='string'? d.detail: JSON.stringify(d.detail);}catch{ try{ t = await res.text(); }catch{} } throw new Error(t||`HTTP ${res.status}`); }
            msg.textContent='Logged'; msg.className='msg ok';
          }catch(e){ msg.textContent = e.message || String(e); msg.className='msg err'; }
        };

        qsEl.appendChild(wrap);
      });
    }

    async function fetchQuizLogs() {
      const params = new URLSearchParams();
      const trial = (trialEl.value || '').trim();
      if (trial) params.set('trial', trial);
      // Limit large responses for perf; adjust as needed
      params.set('n', '1000');
      params.set('order', 'latest');
      const url = api(`/logs?${params.toString()}`);
      const r = await fetch(url);
      if (!r.ok) throw new Error(`Failed to load logs: HTTP ${r.status}`);
      const data = await r.json();
      return Array.isArray(data.logs) ? data.logs : [];
    }

    function buildStats(logs) {
      // Filter only quiz logs produced by echo([payload]) where payload.kind === 'quiz'
      const quiz = [];
      for (const row of logs) {
        try {
          const args = row.args_json; // already parsed by server
          if (Array.isArray(args) && args.length > 0 && args[0] && args[0].kind === 'quiz') {
            const p = args[0];
            quiz.push({
              ts: row.ts,
              student_id: row.student_id,
              qid: p.qid,
              choice_index: Number(p.choice_index)
            });
          }
        } catch {}
      }

      // Map question id -> per-choice counts
      const qIndex = new Map(QUESTIONS.map((q, i) => [q.id, { idx: i, q }]))
      const counts = QUESTIONS.map(q => Array(q.choices.length).fill(0));
      const totalPerQ = QUESTIONS.map(_ => 0);

      // Optionally dedupe by (student_id, qid) keeping latest
      let events = quiz;
      if (dedupeEl.checked) {
        const latest = new Map(); // key -> event
        for (const e of quiz) {
          const key = `${e.qid}::${e.student_id}`;
          const prev = latest.get(key);
          if (!prev || e.ts > prev.ts) latest.set(key, e);
        }
        events = Array.from(latest.values());
      }

      for (const e of events) {
        const qi = qIndex.get(e.qid);
        if (!qi) continue;
        const i = qi.idx;
        if (Number.isFinite(e.choice_index) && e.choice_index >= 0 && e.choice_index < counts[i].length) {
          counts[i][e.choice_index]++;
          totalPerQ[i]++;
        }
      }

      return { counts, totalPerQ };
    }

    function renderStats({ counts, totalPerQ }) {
      const col = (s) => `<td style="padding:6px 8px; border-bottom:1px solid var(--border); text-align:center">${s}</td>`;
      const head = (s) => `<th style="padding:6px 8px; border-bottom:1px solid var(--border); text-align:center; font-weight:600">${s}</th>`;
      let html = '';
      html += '<h3 style="margin:0 0 8px 0">Answer Statistics</h3>';
      html += '<div class="msg" style="margin-bottom:8px">Distribution of answers per question' + (dedupeEl.checked? ' (deduped by student, latest)': '') + '.</div>';
      html += '<div style="overflow:auto">';
      html += '<table style="width:100%; border-collapse:collapse">';
      html += '<thead><tr>' + head('#') + head('Question') + head('Total') + QUESTIONS[0].choices.map((_,i)=> head(String.fromCharCode(65+i))).join('') + head('Correct %') + '</tr></thead>';
      html += '<tbody>';
      QUESTIONS.forEach((q, i) => {
        const totals = counts[i] || [];
        const total = totalPerQ[i] || 0;
        const correct = (typeof q.correct === 'number') ? (totals[q.correct] || 0) : 0;
        const pct = total ? Math.round((100 * correct) / total) : 0;
        const short = q.text.length > 80 ? q.text.slice(0,77) + '…' : q.text;
        html += '<tr>'
          + col(i+1)
          + col(short)
          + col(total)
          + q.choices.map((_,j)=> col(totals[j] || 0)).join('')
          + col(pct + '%')
          + '</tr>';
      });
      html += '</tbody></table></div>';
      statsPanel.innerHTML = html;
      statsPanel.style.display = '';
    }

    async function showStats() {
      statsStatus.textContent = 'Loading…'; statsStatus.className = 'msg';
      try {
        const logs = await fetchQuizLogs();
        const data = buildStats(logs);
        renderStats(data);
        statsStatus.textContent = 'Updated'; statsStatus.className = 'msg ok';
      } catch (e) {
        statsStatus.textContent = e.message || String(e); statsStatus.className = 'msg err';
        statsPanel.style.display = 'none';
      }
    }

    statsBtn.addEventListener('click', showStats);
    // Initialize the quiz
    (async () => {
      qsEl.innerHTML = '<div style="text-align:center;padding:20px;">Loading questions...</div>';
      try {
        await loadQuestions();
        console.log('Loaded questions:', QUESTIONS);
        render();
      } catch (error) {
        console.error('Failed to initialize quiz:', error);
        qsEl.innerHTML = '<div style="text-align:center;padding:20px;color:red;">Failed to load questions. Using fallback questions.</div>';
        setTimeout(() => render(), 1000);
      }
    })();
  </script>
</body>
</html>
