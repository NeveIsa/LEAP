<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Power Method Visualization</title>
    <link rel="stylesheet" href="style/main.css" />
    <script src="https://cdn.jsdelivr.net/npm/@marimo-team/marimo-snippets@1"></script>
    <style>
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        .back-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
        }
        .back-btn:hover {
            background: #545b62;
        }
        .notebook-section {
            margin-bottom: 40px;
        }
        .notebook-title {
            color: #e0e0e0;
            margin-bottom: 20px;
            font-size: 24px;
        }
    </style>
</head>
<body class="page-centered">
    <div class="container">
        <div class="header">
            <h1 style="margin:0; color: #e0e0e0;">Power Method</h1>
            <a href="dashboard.html" class="back-btn">Back to Dashboard</a>
        </div>

        <div class="notebook-section">
            <h2 class="notebook-title">Instructor Visualization</h2>
            <marimo-iframe data-theme="dark" data-height="600px">
                <pre><code class="language-python">import marimo as mo
import requests as req
import numpy as np
import json
import matplotlib.pyplot as plt</code></pre>

                <pre><code class="language-python"># Instructor instructions
mo.md("""
## Visualization Guide

1. Select the student and activity focus below.
2. Fetch logs to retrieve recorded power-method calls.
3. Run the analysis cell to visualise eigenvalue estimates and residuals.
4. Compare convergence against the true dominant eigenvalue (-4).
""")</code></pre>

                <pre><code class="language-python"># Log fetch parameters
student_id_input = mo.ui.text(
    value="",
    placeholder="Enter student ID",
    label="Student ID (sid):"
)

trial_input = mo.ui.text(
    value="",
    placeholder="Enter trial name (e.g., power-method-demo)",
    label="Trial Name:"
)

count_input = mo.ui.number(
    value=20,
    start=1,
    stop=200,
    step=1,
    label="Number of logs (n):"
)

order_input = mo.ui.dropdown(
    options=["latest", "earliest"],
    value="latest",
    label="Order:"
)

mo.vstack([
    mo.md("**Log Fetch Parameters:**"),
    trial_input,
    student_id_input,
    mo.hstack([count_input, order_input])
])</code></pre>

                <pre><code class="language-python"># Fetch logs from the server
params = {
    "sid": student_id_input.value,
    "trial": trial_input.value,
    "n": count_input.value,
    "order": order_input.value,
}
response = req.get("http://localhost:9000/logs", params=params)
response.raise_for_status()
logs = response.json().get("logs", [])
print(f"Fetched {len(logs)} logs")</code></pre>

                <pre><code class="language-python"># Extract power method iterations and matrix columns from client.linear calls
def parse_json(payload):
    if isinstance(payload, str):
        try:
            return json.loads(payload)
        except json.JSONDecodeError:
            return None
    return payload

# Extract all linear calls and sort chronologically
linear_calls = []
for log in logs:
    if log.get("func_name") != "linear":
        continue
    x = parse_json(log.get("args_json"))
    result = parse_json(log.get("result_json"))
    ts = log.get("ts")
    
    if isinstance(x, list) and len(x) == 2 and isinstance(result, list) and len(result) == 2:
        x_arr = np.array(x, dtype=float)
        y_arr = np.array(result, dtype=float)
        linear_calls.append((ts, x_arr, y_arr))

linear_calls.sort(key=lambda t: t[0] or "")

# Find matrix columns (e1, e2) and power method iterations
e1_result = None
e2_result = None
power_method_vectors = []

for ts, x_arr, y_arr in linear_calls:
    # Check if this is a matrix column call
    if np.allclose(x_arr, [1.0, 0.0]):
        e1_result = y_arr
        print(f"Found e1 result: {e1_result}")
    elif np.allclose(x_arr, [0.0, 1.0]):
        e2_result = y_arr
        print(f"Found e2 result: {e2_result}")
    else:
        # This is a power method iteration
        power_method_vectors.append(x_arr)

# Reconstruct matrix and compute true eigenvector
if e1_result is not None and e2_result is not None:
    A = np.column_stack([e1_result, e2_result])
    eigvals, eigvecs = np.linalg.eig(A)
    sorted_indices = np.argsort(np.abs(eigvals))[::-1]
    true_eigenval = float(eigvals[sorted_indices[0]])
    true_eigenvec = eigvecs[:, sorted_indices[0]].astype(float)
    true_eigenvec = true_eigenvec / np.linalg.norm(true_eigenvec)
    print(f"Matrix reconstructed: {A.tolist()}")
    print(f"True dominant eigenvalue: {true_eigenval:.6f}")
    print(f"True dominant eigenvector: {true_eigenvec.tolist()}")
else:
    print("Could not reconstruct matrix - missing e1 or e2 results")
    true_eigenval = -4.0  # Known value for [[-1,-3],[-3,-1]]
    true_eigenvec = np.array([1.0, 1.0]) / np.sqrt(2)  # Known eigenvector

print(f"Found {len(power_method_vectors)} power method iterations")

power_method_vectors</code></pre>

                <pre><code class="language-python"># Simple scatter plot: power method iterations vs true eigenvector
if len(power_method_vectors) == 0:
    print("No power method iterations found in the selected logs.")
else:
    plt.figure(figsize=(8, 8))
    
    # Plot power method iterations as blue dots
    for i, vec in enumerate(power_method_vectors):
        plt.scatter(vec[0], vec[1], s=100, alpha=0.7, color='blue', 
                   label="Power method iterations" if i == 0 else "")
    
    # Plot true dominant eigenvector as red star
    plt.scatter(true_eigenvec[0], true_eigenvec[1], s=200, marker='*', 
               color='red', label=f"True eigenvector (λ={true_eigenval:.2f})")
    
    plt.xlabel("x₁")
    plt.ylabel("x₂") 
    plt.title("Power Method: Iterations vs True Eigenvector")
    plt.legend()
    plt.grid(alpha=0.3)
    plt.axis('equal')
    plt.show()
    
    print(f"Plotted {len(power_method_vectors)} power method iterations")
    print(f"True eigenvalue: {true_eigenval:.6f}")
    print(f"True eigenvector: {true_eigenvec.tolist()}")</code></pre>
            </marimo-iframe>
        </div>
    </div>

    <script>
        const API_BASE_URL = window.location.origin;

        // Require authentication to view dashboard
        (async () => {
            try {
                const resp = await fetch(`${API_BASE_URL}/admin/ping`, { credentials: 'include' });
                if (!resp.ok) {
                    window.location.href = 'login.html';
                }
            } catch (e) {
                window.location.href = 'login.html';
            }
        })();
    </script>
</body>
</html>