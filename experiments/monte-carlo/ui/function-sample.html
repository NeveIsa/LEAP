<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Monte Carlo Function Sampling</title>
  <link rel="stylesheet" href="style/main.css" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
    body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin-bottom: 20px; }
    .controls .field { display: flex; flex-direction: column; gap: 6px; }
    .panel {
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: linear-gradient(135deg, rgba(17, 24, 39, 0.9), rgba(30, 41, 59, 0.92));
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 18px 32px rgba(2,6,23,.32);
    }
    html[data-theme='light'] .panel {
      background: linear-gradient(135deg, rgba(255,255,255,0.98), rgba(243,244,246,0.98));
      box-shadow: 0 16px 30px rgba(15,20,34,.12);
    }
    .panel h3 { font-size: 20px; margin: 0; color: var(--primary-color); }
    .panel p { margin: 0; color: var(--muted-color); font-size: 14px; }
    .viz {
      display: grid; grid-template-columns: 1fr 400px; gap: 18px; align-items: start;
    }
    @media (max-width: 900px) { .viz { grid-template-columns: 1fr; } }
    .viz-card {
      background: linear-gradient(180deg, rgba(28,36,54,.96), rgba(25,34,51,.92));
      border: 1px solid var(--border-color); border-radius: 16px; padding: 16px;
      box-shadow: 0 10px 20px rgba(2,6,23,.28), inset 0 1px 0 rgba(255,255,255,.04);
    }
    html[data-theme='light'] .viz-card { background: linear-gradient(180deg, rgba(255,255,255,.96), rgba(247,249,252,.96)); }
    .function-wrap { display:flex; align-items:center; justify-content:center; }
    #function-plot { width: 400px; height: 300px; border-radius: 14px; display:block; }
    .result {
      display:flex; align-items:center; justify-content:center; min-height: 64px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; font-size: 20px;
      color: var(--secondary-color);
      background: linear-gradient(180deg, rgba(28,36,54,.96), rgba(25,34,51,.92));
      border: 1px solid var(--border-color); border-radius: 10px; padding: 10px 12px;
      box-shadow: 0 10px 20px rgba(2,6,23,.28), inset 0 1px 0 rgba(255,255,255,.04);
    }
    html[data-theme='light'] .result {
      color: #0f1422;
      background: linear-gradient(180deg, rgba(255,255,255,.96), rgba(247,249,252,.96));
      box-shadow: 0 10px 20px rgba(15,20,34,.12), inset 0 1px 0 rgba(255,255,255,.6);
    }
    #sample-btn {
      height: 56px;
      font-size: 18px;
      font-weight: 700;
      border-radius: 12px;
      width: 100%;
    }
    .msg { font-size: 13px; color: var(--muted-color); min-height: 1.2em; margin-top: 8px; }
    .msg.ok { color: var(--success-color); }
    .msg.err { color: var(--error-color); }
    .hint { font-size: 12px; color: var(--muted-color); }
    .function-info {
      background: rgba(34, 211, 238, 0.1);
      border: 1px solid rgba(34, 211, 238, 0.3);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
    }
    .function-info h4 {
      margin: 0 0 8px 0;
      color: #22d3ee;
      font-size: 16px;
    }
    .function-info code {
      background: rgba(0,0,0,0.3);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: ui-monospace, monospace;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="toolbar" style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
      <a href="dashboard.html">&larr; Back</a>
      <div style="flex:1"></div>
      <span class="badge" id="active">Active: ...</span>
    </div>
    <h1>Monte Carlo Function Sampling</h1>
    <p style="margin-top:-6px; color: var(--muted-color);">Sample random points to estimate the area under a function curve over [-1, 1].</p>

    <div class="controls">
      <div class="field">
        <label for="studentId">Student ID</label>
        <input id="studentId" type="text" placeholder="e.g. s001" />
      </div>
      <div class="field">
        <label for="experimentName">Experiment Name</label>
        <input id="experimentName" type="text" placeholder="auto-detected" disabled />
      </div>
      <div class="field">
        <label for="trial">Trial Name / ID</label>
        <input id="trial" type="text" placeholder="e.g. func-lesson-1" />
      </div>
    </div>

    <div id="function-status" class="function-info" style="display: none;">
      <h4>Current Function</h4>
      <p>f(x) = <code id="current-function-display"></code></p>
    </div>

    <div id="no-function-warning" class="function-info" style="display: none; background: rgba(248, 113, 113, 0.1); border-color: rgba(248, 113, 113, 0.3);">
      <h4 style="color: #f87171;">No Function Defined</h4>
      <p>Please ask your instructor to define a function in the Function tab before sampling.</p>
    </div>

    <div class="panel">
      <div>
        <h3>Uniform Point Sampling for Function Integration</h3>
        <p>Each click samples a point in the rectangle and checks if it's under the function curve.</p>
      </div>
      <div class="viz">
        <div>
          <div class="result" id="sample-output">--</div>
          <button class="btn" id="sample-btn" style="margin-top:12px;" disabled>Sample Point</button>
          <div class="msg" id="sample-msg"></div>
          <div class="hint">Preview only; data is not sent to the server.</div>
        </div>
        <div class="viz-card">
          <div class="function-wrap">
            <canvas id="function-plot" width="400" height="300"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const sidEl = document.getElementById('studentId');
    const expNameEl = document.getElementById('experimentName');
    const trialEl = document.getElementById('trial');
    const outputEl = document.getElementById('sample-output');
    const msgEl = document.getElementById('sample-msg');
    const sampleBtn = document.getElementById('sample-btn');
    const canvas = document.getElementById('function-plot');
    const ctx = canvas.getContext('2d');
    const functionStatus = document.getElementById('function-status');
    const noFunctionWarning = document.getElementById('no-function-warning');
    const currentFunctionDisplay = document.getElementById('current-function-display');

    let currentFunction = null;
    let maxFunctionValue = 1;
    
    // Store previous points for persistence
    let previousPoints = [];

    sidEl.value = localStorage.getItem('monte.function.sid') || '';
    expNameEl.value = localStorage.getItem('monte.function.expName') || '';
    trialEl.value = localStorage.getItem('monte.function.trial') || '';

    sidEl.addEventListener('input', () => localStorage.setItem('monte.function.sid', sidEl.value.trim()));
    expNameEl.addEventListener('input', () => localStorage.setItem('monte.function.expName', expNameEl.value.trim()));
    trialEl.addEventListener('input', () => localStorage.setItem('monte.function.trial', trialEl.value.trim()));

    // Load current function
    function loadCurrentFunction() {
      try {
        const stored = localStorage.getItem('monte-carlo-function');
        if (stored) {
          const funcData = JSON.parse(stored);
          currentFunction = funcData.expression;
          currentFunctionDisplay.textContent = currentFunction;
          functionStatus.style.display = 'block';
          noFunctionWarning.style.display = 'none';
          sampleBtn.disabled = false;
          
          // Calculate max function value for plotting
          calculateMaxFunctionValue();
          // Clear previous points when function changes
          previousPoints = [];
          drawScene();
          return true;
        } else {
          functionStatus.style.display = 'none';
          noFunctionWarning.style.display = 'block';
          sampleBtn.disabled = true;
          drawScene();
          return false;
        }
      } catch (error) {
        console.error('Error loading function:', error);
        functionStatus.style.display = 'none';
        noFunctionWarning.style.display = 'block';
        sampleBtn.disabled = true;
        drawScene();
        return false;
      }
    }

    function calculateMaxFunctionValue() {
      if (!currentFunction) return;
      
      try {
        let max = 0;
        for (let i = -1; i <= 1; i += 0.1) {
          const value = evaluateFunction(currentFunction, i);
          if (value > max) max = value;
        }
        maxFunctionValue = Math.max(max * 1.1, 1);
      } catch (error) {
        maxFunctionValue = 5; // fallback
      }
    }

    function evaluateFunction(expr, x) {
      // Safe evaluation function
      let evalExpr = expr.replace(/\bx\b/g, `(${x})`);
      const context = {
        Math: Math,
        sin: Math.sin,
        cos: Math.cos,
        tan: Math.tan,
        exp: Math.exp,
        log: Math.log,
        sqrt: Math.sqrt,
        abs: Math.abs,
        pow: Math.pow,
        PI: Math.PI,
        E: Math.E
      };
      const func = new Function(...Object.keys(context), `return ${evalExpr}`);
      return func(...Object.values(context));
    }

    (async () => {
      try {
        const match = window.location.pathname.match(/\/exp\/([^\/]+)/);
        if (match && match[1]) {
          if (!expNameEl.value) {
            expNameEl.value = match[1];
            localStorage.setItem('monte.function.expName', expNameEl.value.trim());
          }
          return;
        }
        if (!expNameEl.value) {
          const res = await fetch(`${window.location.origin}/api/active-experiment`).catch(() => null);
          if (res && res.ok) {
            const data = await res.json();
            if (data && data.active && !expNameEl.value) {
              expNameEl.value = data.active;
              localStorage.setItem('monte.function.expName', expNameEl.value.trim());
            }
          }
        }
      } catch (_) {}
    })();

    (async function(){
      try {
        const res = await fetch(`${window.location.origin}/api/active-experiment`);
        if (res.ok) {
          const data = await res.json();
          document.getElementById('active').textContent = `Active: ${data.active || 'none'}`;
        }
      } catch {}
    })();

    function randomFunctionPoint() {
      const x = 2 * Math.random() - 1; // [-1, 1]
      const y = Math.random() * maxFunctionValue; // [0, maxFunctionValue]
      return [Number(x.toFixed(6)), Number(y.toFixed(6))];
    }

    function nowIso() { return new Date().toISOString(); }

    function ensureRequiredFields() {
      const sid = sidEl.value.trim();
      if (!sid) throw new Error('Please enter Student ID');
      const trial = trialEl.value.trim();
      if (!trial) throw new Error('Please enter Trial Name/ID');
      return { sid, trial };
    }

    async function sendResult(value) {
      const { sid, trial } = ensureRequiredFields();
      const payload = { kind: 'func_pm', value, ts: nowIso() };
      let experiment_name = '';
      try {
        const res = await fetch(`${window.location.origin}/api/active-experiment`);
        if (res.ok) {
          const data = await res.json();
          experiment_name = data.active || '';
        }
      } catch {}
      const body = { student_id: sid, func_name: 'echo', args: [payload], trial, experiment_name };
      const url = `${window.location.origin}/call`;
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      if (!res.ok) {
        let message = '';
        try {
          const data = await res.json();
          if (data && data.detail !== undefined) {
            message = typeof data.detail === 'string' ? data.detail : JSON.stringify(data.detail);
          }
        } catch {
          try { message = await res.text(); } catch {}
        }
        throw new Error(message || `HTTP ${res.status}`);
      }
      return res.json();
    }

    // Drawing helpers
    function drawScene(newPoint) {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      
      // Background
      const grad = ctx.createLinearGradient(0, 0, w, h);
      grad.addColorStop(0, '#0f172a');
      grad.addColorStop(1, '#111827');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
      
      // Inner panel
      ctx.save();
      ctx.translate(12, 12);
      const plotW = w - 24;
      const plotH = h - 24;
      
      // Background rectangle
      ctx.fillStyle = 'rgba(148,163,184,0.06)';
      ctx.strokeStyle = 'rgba(148,163,184,0.5)';
      ctx.lineWidth = 1.2;
      roundRect(ctx, 0, 0, plotW, plotH, 12, true, true);
      
      // Grid
      ctx.strokeStyle = 'rgba(148,163,184,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let i = 1; i < 10; i++) {
        const tx = (i / 10) * plotW;
        const ty = (i / 10) * plotH;
        ctx.moveTo(tx, 0); ctx.lineTo(tx, plotH);
        ctx.moveTo(0, ty); ctx.lineTo(plotW, ty);
      }
      ctx.stroke();
      
      // Draw function curve if available
      if (currentFunction) {
        try {
          ctx.strokeStyle = '#22d3ee';
          ctx.lineWidth = 2;
          ctx.beginPath();
          
          const numPoints = 200;
          for (let i = 0; i <= numPoints; i++) {
            const x = -1 + (2 * i) / numPoints;
            const funcY = evaluateFunction(currentFunction, x);
            const screenX = ((x + 1) / 2) * plotW;
            const screenY = plotH - (funcY / maxFunctionValue) * plotH;
            
            if (i === 0) {
              ctx.moveTo(screenX, screenY);
            } else {
              ctx.lineTo(screenX, screenY);
            }
          }
          ctx.stroke();
          
          // Fill area under curve
          ctx.fillStyle = 'rgba(34, 211, 238, 0.2)';
          ctx.fill();
          
        } catch (error) {
          // Function error - show error text
          ctx.fillStyle = '#f87171';
          ctx.font = '14px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('Function Error', plotW/2, plotH/2);
        }
      } else {
        // No function defined
        ctx.fillStyle = '#f87171';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('No Function Defined', plotW/2, plotH/2);
      }
      
      // Axes
      ctx.strokeStyle = 'rgba(148,163,184,0.6)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(plotW/2, 0); ctx.lineTo(plotW/2, plotH); // Y-axis
      ctx.moveTo(0, plotH); ctx.lineTo(plotW, plotH); // X-axis
      ctx.stroke();
      
      // Draw all previous points with fading alpha
      for (let i = 0; i < previousPoints.length; i++) {
        const point = previousPoints[i];
        const [x, y] = point.coords;
        const px = ((x + 1) / 2) * plotW;
        const py = plotH - (y / maxFunctionValue) * plotH;
        const underCurve = point.underCurve;
        
        // Calculate alpha based on age (newer = more opaque)
        const age = previousPoints.length - i;
        const maxAge = Math.min(previousPoints.length, 20); // Show up to 20 previous points
        const alpha = Math.max(0.1, 1 - (age / maxAge));
        
        const r = 4; // Slightly smaller for previous points
        ctx.fillStyle = underCurve ? `rgba(52,211,153,${alpha})` : `rgba(248,113,113,${alpha})`;
        ctx.beginPath(); 
        ctx.arc(px, py, r, 0, Math.PI*2); 
        ctx.fill();
      }
      
      // Sample point (new point with full opacity)
      if (newPoint && currentFunction) {
        const [x, y] = newPoint; // x in [-1,1], y in [0, maxFunctionValue]
        const px = ((x + 1) / 2) * plotW;
        const py = plotH - (y / maxFunctionValue) * plotH;
        
        // Check if point is under the curve
        let underCurve = false;
        try {
          const funcValue = evaluateFunction(currentFunction, x);
          underCurve = y <= funcValue;
        } catch (error) {
          underCurve = false;
        }
        
        const r = 6;
        const glow = ctx.createRadialGradient(px, py, 0, px, py, 16);
        glow.addColorStop(0, underCurve ? 'rgba(52,211,153,0.6)' : 'rgba(248,113,113,0.6)');
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glow;
        ctx.beginPath(); ctx.arc(px, py, 16, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = underCurve ? '#34d399' : '#f87171';
        ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI*2); ctx.fill();
        
        // Add this point to previous points
        previousPoints.push({
          coords: [x, y],
          underCurve: underCurve,
          timestamp: Date.now()
        });
        
        // Limit the number of stored points to prevent memory issues
        if (previousPoints.length > 50) {
          previousPoints.shift(); // Remove oldest point
        }
      }
      
      ctx.restore();
    }

    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof radius === 'number') {
        radius = {tl: radius, tr: radius, br: radius, bl: radius};
      } else {
        radius = Object.assign({tl: 0, tr: 0, br: 0, bl: 0}, radius);
      }
      ctx.beginPath();
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + width - radius.tr, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      ctx.lineTo(x + width, y + height - radius.br);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
      ctx.lineTo(x, y + radius.tl);
      ctx.quadraticCurveTo(x, y, x + radius.tl, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    // Initialize
    loadCurrentFunction();

    // Refresh function periodically
    setInterval(loadCurrentFunction, 5000);

    document.getElementById('sample-btn').addEventListener('click', async () => {
      if (!currentFunction) {
        msgEl.textContent = 'No function defined. Ask instructor to set up a function.';
        msgEl.className = 'msg err';
        return;
      }
      
      try {
        const value = randomFunctionPoint();
        outputEl.textContent = JSON.stringify(value);
        drawScene(value);
        msgEl.textContent = 'Logging...';
        msgEl.className = 'msg';
        await sendResult(value);
        msgEl.textContent = 'Logged';
        msgEl.className = 'msg ok';
      } catch (err) {
        msgEl.textContent = (err && err.message) ? err.message : String(err);
        msgEl.className = 'msg err';
      }
    });
  </script>
  <script src="scripts/theme.js"></script>
</body>
</html>
