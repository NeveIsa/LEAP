<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Logs Line Plot</title>
  <link rel="stylesheet" href="https://unpkg.com/uplot/dist/uPlot.min.css" />
  <link rel="stylesheet" href="../style/main.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Student Logs Line Plot</h1>
      <p class="subtle">Plots the last 100 logs by timestamp; each student is a separate series.</p>

      <div class="toolbar" style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
        <a href="../dashboard.html">← Back to Dashboard</a>
        <div style="flex:1"></div>
        <label for="studentSelect">Student:</label>
        <select id="studentSelect" class="input">
          <option>Loading…</option>
        </select>
        <label for="expSelect">Experiment:</label>
        <select id="expSelect" class="input">
          <option>Loading…</option>
        </select>
        <span class="badge" id="countBadge">Loading…</span>
      </div>

      <div id="plot"></div>
      <div class="legend" id="legend"></div>
      <div class="message" id="message"></div>
    </div>
  </div>

  <script src="https://unpkg.com/uplot/dist/uPlot.iife.min.js"></script>
  <script>
    const API_BASE_URL = window.location.origin;
    const QS = new URLSearchParams(window.location.search);
    const QS_SID = QS.get('sid') || '';
    const QS_EXP = QS.get('exp') || '';

    async function fetchLogs() {
      try {
        const url = new URL(`${API_BASE_URL}/logs`);
        url.searchParams.set('n', '100');
        url.searchParams.set('order', 'earliest');
        if (QS_SID) url.searchParams.set('sid', QS_SID);
        if (QS_EXP) url.searchParams.set('exp', QS_EXP);
        const res = await fetch(url.toString());
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        return data.logs || [];
      } catch (e) {
        console.error('Failed to fetch logs', e);
        setMessage('Failed to fetch logs. Is the server running?');
        return null;
      }
    }

    async function fetchOptions() {
      try {
        const res = await fetch(`${API_BASE_URL}/log-options`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      } catch (e) {
        console.warn('Failed to fetch log options, will derive from logs as fallback.', e);
        return null;
      }
    }

    function setMessage(msg) {
      document.getElementById('message').textContent = msg || '';
    }

    function tryParseNumber(v) {
      if (v == null) return NaN;
      try {
        // result_json is stored as a JSON string; try JSON.parse first
        const parsed = typeof v === 'string' ? JSON.parse(v) : v;
        if (typeof parsed === 'number') return parsed;
        const f = parseFloat(parsed);
        return Number.isFinite(f) ? f : NaN;
      } catch {
        const f = parseFloat(v);
        return Number.isFinite(f) ? f : NaN;
      }
    }

    function prepareSeries(logs) {
      // Unique, sorted timestamps (ms since epoch)
      const timesSet = new Set();
      const byStudent = new Map(); // student_id -> Map(ts -> value)

      for (const log of logs) {
        const t = Date.parse(log.ts);
        if (!Number.isFinite(t)) continue;
        timesSet.add(t);

        const sid = log.student_id || 'unknown';
        const y = tryParseNumber(log.result_json);
        if (!byStudent.has(sid)) byStudent.set(sid, new Map());
        // if multiple at same ts, overwrite with latest in order; fine
        byStudent.get(sid).set(t, Number.isFinite(y) ? y : NaN);
      }

      const xs = Array.from(timesSet).sort((a, b) => a - b);

      // Build aligned Y arrays per student
      const students = Array.from(byStudent.keys()).sort();
      const ys = students.map(sid => xs.map(ts => {
        const v = byStudent.get(sid).get(ts);
        return v === undefined ? NaN : v;
      }));

      return { xs, students, ys };
    }

    function renderLegend(students, colors) {
      const el = document.getElementById('legend');
      el.innerHTML = '';
      students.forEach((sid, i) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        const sw = document.createElement('span');
        sw.className = 'swatch';
        sw.style.background = colors[i % colors.length];
        const label = document.createElement('span');
        label.textContent = sid;
        item.appendChild(sw);
        item.appendChild(label);
        el.appendChild(item);
      });
    }

    function uniqueSorted(arr) {
      return Array.from(new Set(arr)).sort((a, b) => {
        if (a === b) return 0;
        return a < b ? -1 : 1;
      });
    }

    function populateSelect(sel, values, placeholder) {
      sel.innerHTML = '';
      const optAll = document.createElement('option');
      optAll.value = '';
      optAll.textContent = placeholder;
      sel.appendChild(optAll);
      for (const v of values) {
        if (!v) continue;
        const o = document.createElement('option');
        o.value = v;
        o.textContent = v;
        sel.appendChild(o);
      }
    }

    function filterLogs(logs, sid, exp) {
      return logs.filter(l => {
        const sidOk = !sid || l.student_id === sid;
        const expOk = !exp || l.experiment_name === exp;
        return sidOk && expOk;
      });
    }

    function buildAndRender(logs, sid, exp) {
      const filtered = filterLogs(logs, sid, exp);
      document.getElementById('countBadge').textContent = `${filtered.length} logs`;
      const plotEl = document.getElementById('plot');
      plotEl.innerHTML = '';
      document.getElementById('legend').innerHTML = '';
      setMessage('');

      if (filtered.length === 0) {
        setMessage('No logs for the selected filters.');
        return;
      }

      const { xs, students, ys } = prepareSeries(filtered);
      if (xs.length === 0 || students.length === 0) {
        setMessage('No plottable numeric results for the selected filters.');
        return;
      }

      const colors = [
        '#00f5d4', '#f15bb5', '#fee440', '#00bbf9', '#9b5de5',
        '#ef476f', '#06d6a0', '#ffd166', '#118ab2', '#073b4c',
      ];
      const series = [
        { label: 'time' },
        ...students.map((sid, i) => ({ label: sid, stroke: colors[i % colors.length], width: 2, spanGaps: true }))
      ];
      const data = [xs, ...ys];
      const opts = {
        title: 'Last 100 Logs',
        width: plotEl.clientWidth,
        height: 420,
        series,
        axes: [
          { scale: 'x', label: 'Time', stroke: '#00f5d4', grid: { show: true }, values: (u, s) => s.map(v => new Date(v).toLocaleString([], { hour12: false, year: '2-digit', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' })) },
          { scale: 'y', label: 'Result', stroke: '#00f5d4', grid: { show: true } },
        ],
        scales: { x: { time: true } },
      };
      const u = new uPlot(opts, data, plotEl);
      renderLegend(students, colors);

      let resizeTO;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTO);
        resizeTO = setTimeout(() => u.setSize({ width: plotEl.clientWidth, height: 420 }), 100);
      });
    }

    async function main() {
      const logs = await fetchLogs();
      if (!logs) return;

      const sSel = document.getElementById('studentSelect');
      const eSel = document.getElementById('expSelect');

      // Prefer server-provided options to include all values; fallback to deriving from logs
      let opts = await fetchOptions();
      let students = opts && Array.isArray(opts.students) ? opts.students : uniqueSorted(logs.map(l => l.student_id).filter(Boolean));
      let experiments = opts && Array.isArray(opts.experiments) ? opts.experiments : uniqueSorted(logs.map(l => l.experiment_name).filter(Boolean));

      // Restore last selections
      const savedSid = localStorage.getItem('viz.sid') || '';
      const savedExp = localStorage.getItem('viz.exp') || '';
      const initSid = QS_SID || savedSid;
      const initExp = QS_EXP || savedExp;

      populateSelect(sSel, students, 'All students');
      populateSelect(eSel, experiments, 'All experiments');

      if (initSid) sSel.value = initSid;
      if (initExp) eSel.value = initExp;

      function rerender() {
        localStorage.setItem('viz.sid', sSel.value);
        localStorage.setItem('viz.exp', eSel.value);
        buildAndRender(logs, sSel.value, eSel.value);
      }

      sSel.addEventListener('change', rerender);
      eSel.addEventListener('change', rerender);

      // Initial render
      rerender();
    }

    document.addEventListener('DOMContentLoaded', main);
  </script>
</body>
</html>
