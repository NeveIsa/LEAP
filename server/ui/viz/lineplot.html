<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Logs Dashboard</title>
  <link rel="stylesheet" href="https://unpkg.com/uplot/dist/uPlot.min.css" />
  <link rel="stylesheet" href="../style/main.css" />
  <style>
    .ide-container {
      margin-top: 30px;
      border-top: 2px solid var(--border-color);
      padding-top: 20px;
    }
    
    .ide-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .ide-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .function-input {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .function-input input {
      flex: 1;
      min-width: 200px;
    }
    
    .editor-container {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
      height: 400px;
      margin-bottom: 15px;
    }
    
    .transform-btn {
      background: var(--primary-color);
      color: var(--background-color);
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .transform-btn:hover {
      background: #00d4b3;
      transform: translateY(-1px);
    }
    
    .transform-btn:disabled {
      background: var(--muted-color);
      cursor: not-allowed;
      transform: none;
    }
    
    .results-panel {
      background: var(--surface-color);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }
    
    .results-panel h3 {
      margin-top: 0;
      color: var(--primary-color);
    }
    
    .metric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-top: 10px;
    }
    
    .metric-card {
      background: #333;
      padding: 12px;
      border-radius: 6px;
      text-align: center;
    }
    
    .metric-value {
      font-size: 24px;
      font-weight: 600;
      color: var(--primary-color);
    }
    
    .metric-label {
      font-size: 12px;
      color: var(--muted-color);
      margin-top: 5px;
    }
    
    .error-message {
      background: rgba(var(--error-rgb), 0.1);
      border: 1px solid var(--error-color);
      color: var(--error-color);
      padding: 10px;
      border-radius: 6px;
      margin-top: 10px;
    }
    
    .success-message {
      background: rgba(var(--success-rgb), 0.1);
      border: 1px solid var(--success-color);
      color: var(--success-color);
      padding: 10px;
      border-radius: 6px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Interactive Logs Dashboard</h1>
      <p class="subtle">Interactive visualization with custom transformation functions. Scroll down for the IDE environment.</p>

      <div class="toolbar" style="display:flex; align-items:center; gap:12px; flex-wrap:wrap;">
        <a href="../dashboard.html">← Back to Dashboard</a>
        <div style="flex:1"></div>
        <label for="studentSelect">Student:</label>
        <select id="studentSelect" class="input">
          <option>Loading…</option>
        </select>
        <label for="expSelect">Experiment:</label>
        <select id="expSelect" class="input">
          <option>Loading…</option>
        </select>
        <span class="badge" id="countBadge">Loading…</span>
      </div>

      <div id="plot"></div>
      <div class="legend" id="legend"></div>
      <div class="message" id="message"></div>

      <!-- Interactive IDE Environment -->
      <div class="ide-container">
        <div class="ide-header">
          <h2>Transformation IDE</h2>
          <div class="ide-controls">
            <button id="transformBtn" class="transform-btn">Transform & Plot</button>
            <button id="resetBtn" class="btn">Reset</button>
          </div>
        </div>

        <div class="function-input">
          <label for="functionName">Function Name:</label>
          <input type="text" id="functionName" placeholder="e.g., calculateEfficiency" value="transform">
          <label for="yAxisLabel">Y-Axis Label:</label>
          <input type="text" id="yAxisLabel" placeholder="e.g., Efficiency Score" value="Transformed Value">
        </div>

        <div class="editor-container" id="editor"></div>

        <div class="results-panel" id="resultsPanel" style="display: none;">
          <h3>Transformation Results</h3>
          <div class="metric-grid" id="metricGrid"></div>
          <div id="transformationMessage"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Monaco Editor -->
  <script src="https://unpkg.com/monaco-editor@0.44.0/min/vs/loader.js"></script>
  <script src="https://unpkg.com/uplot/dist/uPlot.iife.min.js"></script>
  <script>
    const API_BASE_URL = window.location.origin;
    const QS = new URLSearchParams(window.location.search);
    const QS_SID = QS.get('sid') || '';
    const QS_EXP = QS.get('exp') || '';

    let editor;
    let currentPlot;
    let currentLogs = [];

    // Initialize Monaco Editor
    require.config({ paths: { vs: 'https://unpkg.com/monaco-editor@0.44.0/min/vs' } });
    require(['vs/editor/editor.main'], function() {
      editor = monaco.editor.create(document.getElementById('editor'), {
        value: `// Custom transformation function for RPC call analysis
// Parameters: x (array of iteration numbers), y (array of function results)
// Return: array of transformed values
function transform(x, y) {
  // Example: Calculate convergence rate (difference between consecutive values)
  const result = [];
  
  for (let i = 0; i < y.length; i++) {
    if (i === 0) {
      result.push(0); // First iteration has no previous value
    } else {
      const diff = Math.abs(y[i] - y[i-1]);
      result.push(diff);
    }
  }
  
  return result;
}`,
        language: 'javascript',
        theme: 'vs-dark',
        automaticLayout: true,
        minimap: { enabled: false },
        fontSize: 14,
        lineNumbers: 'on',
        roundedSelection: false,
        scrollBeyondLastLine: false,
        readOnly: false,
        cursorStyle: 'line',
        wordWrap: 'on'
      });
    });

    async function fetchLogs() {
      try {
        const url = new URL(`${API_BASE_URL}/logs`);
        url.searchParams.set('n', '100');
        url.searchParams.set('order', 'earliest');
        if (QS_SID) url.searchParams.set('sid', QS_SID);
        if (QS_EXP) url.searchParams.set('exp', QS_EXP);
        const res = await fetch(url.toString());
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        return data.logs || [];
      } catch (e) {
        console.error('Failed to fetch logs', e);
        setMessage('Failed to fetch logs. Is the server running?');
        return null;
      }
    }

    async function fetchOptions() {
      try {
        const res = await fetch(`${API_BASE_URL}/log-options`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      } catch (e) {
        console.warn('Failed to fetch log options, will derive from logs as fallback.', e);
        return null;
      }
    }

    function setMessage(msg) {
      document.getElementById('message').textContent = msg || '';
    }

    function tryParseNumber(v) {
      if (v == null) return NaN;
      try {
        const parsed = typeof v === 'string' ? JSON.parse(v) : v;
        if (typeof parsed === 'number') return parsed;
        const f = parseFloat(parsed);
        return Number.isFinite(f) ? f : NaN;
      } catch {
        const f = parseFloat(v);
        return Number.isFinite(f) ? f : NaN;
      }
    }

    function prepareSeries(logs) {
      // Group logs by student and sort by timestamp to get proper iteration order
      const byStudent = new Map();

      for (const log of logs) {
        const sid = log.student_id || 'unknown';
        const y = tryParseNumber(log.result_json);
        
        if (!byStudent.has(sid)) {
          byStudent.set(sid, []);
        }
        
        // Only add if we have a valid numeric result
        if (Number.isFinite(y)) {
          byStudent.get(sid).push({
            iteration: byStudent.get(sid).length + 1, // Use sequence number as iteration
            value: y,
            timestamp: new Date(log.ts).getTime()
          });
        }
      }

      // Find the maximum number of iterations across all students
      const maxIterations = Math.max(...Array.from(byStudent.values()).map(studentLogs => studentLogs.length));
      
      if (maxIterations === 0) {
        return { xs: [], students: [], ys: [] };
      }

      // Create iteration array (1, 2, 3, ...)
      const xs = Array.from({length: maxIterations}, (_, i) => i + 1);
      
      const students = Array.from(byStudent.keys()).sort();
      const ys = students.map(sid => {
        const studentLogs = byStudent.get(sid);
        return xs.map(iteration => {
          const logEntry = studentLogs.find(log => log.iteration === iteration);
          return logEntry ? logEntry.value : NaN;
        });
      });

      return { xs, students, ys };
    }

    function renderLegend(students, colors) {
      const el = document.getElementById('legend');
      el.innerHTML = '';
      students.forEach((sid, i) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        const sw = document.createElement('span');
        sw.className = 'swatch';
        sw.style.background = colors[i % colors.length];
        const label = document.createElement('span');
        label.textContent = sid;
        item.appendChild(sw);
        item.appendChild(label);
        el.appendChild(item);
      });
    }

    function uniqueSorted(arr) {
      return Array.from(new Set(arr)).sort((a, b) => {
        if (a === b) return 0;
        return a < b ? -1 : 1;
      });
    }

    function populateSelect(sel, values, placeholder) {
      sel.innerHTML = '';
      const optAll = document.createElement('option');
      optAll.value = '';
      optAll.textContent = placeholder;
      sel.appendChild(optAll);
      for (const v of values) {
        if (!v) continue;
        const o = document.createElement('option');
        o.value = v;
        o.textContent = v;
        sel.appendChild(o);
      }
    }

    function filterLogs(logs, sid, exp) {
      return logs.filter(l => {
        const sidOk = !sid || l.student_id === sid;
        const expOk = !exp || l.experiment_name === exp;
        return sidOk && expOk;
      });
    }

    function buildAndRender(logs, sid, exp) {
      const filtered = filterLogs(logs, sid, exp);
      currentLogs = filtered;
      document.getElementById('countBadge').textContent = `${filtered.length} logs`;
      const plotEl = document.getElementById('plot');
      plotEl.innerHTML = '';
      document.getElementById('legend').innerHTML = '';
      setMessage('');

      if (filtered.length === 0) {
        setMessage('No logs for the selected filters.');
        return;
      }

      const { xs, students, ys } = prepareSeries(filtered);
      if (xs.length === 0 || students.length === 0) {
        setMessage('No plottable numeric results for the selected filters.');
        return;
      }

      const colors = [
        '#00f5d4', '#f15bb5', '#fee440', '#00bbf9', '#9b5de5',
        '#ef476f', '#06d6a0', '#ffd166', '#118ab2', '#073b4c',
      ];
      const series = [
        { label: 'iteration' },
        ...students.map((sid, i) => ({ label: sid, stroke: colors[i % colors.length], width: 2, spanGaps: true }))
      ];
      const data = [xs, ...ys];
      const opts = {
        title: 'RPC Call Progress by Iteration',
        width: plotEl.clientWidth,
        height: 420,
        series,
        axes: [
          { scale: 'x', label: 'Iteration Number', stroke: '#00f5d4', grid: { show: true } },
          { scale: 'y', label: 'Function Result', stroke: '#00f5d4', grid: { show: true } },
        ],
      };
      
      if (currentPlot) {
        currentPlot.destroy();
      }
      currentPlot = new uPlot(opts, data, plotEl);
      renderLegend(students, colors);

      let resizeTO;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTO);
        resizeTO = setTimeout(() => currentPlot.setSize({ width: plotEl.clientWidth, height: 420 }), 100);
      });
    }

    function applyTransformation() {
      try {
        const functionName = document.getElementById('functionName').value || 'transform';
        const yAxisLabel = document.getElementById('yAxisLabel').value || 'Transformed Value';
        
        if (currentLogs.length === 0) {
          showTransformationMessage('No logs available for transformation.', 'error');
          return;
        }

        // Get the function code from editor
        const functionCode = editor.getValue();
        
        // Create a safe evaluation environment
        const safeEval = new Function('x', 'y', functionCode + `\nreturn ${functionName}(x, y);`);
        
        const { xs, students, ys } = prepareSeries(currentLogs);
        
        if (xs.length === 0 || students.length === 0) {
          showTransformationMessage('No valid data for transformation.', 'error');
          return;
        }

        // Apply transformation to each student's data
        const transformedYs = ys.map((studentY, studentIndex) => {
          try {
            return safeEval(xs, studentY);
          } catch (error) {
            console.error(`Error transforming data for student ${students[studentIndex]}:`, error);
            return studentY.map(() => NaN);
          }
        });

        // Calculate metrics
        const metrics = calculateMetrics(transformedYs);
        
        // Update the plot with transformed data
        updatePlotWithTransformation(xs, students, transformedYs, yAxisLabel);
        
        // Show results
        showResults(metrics);
        showTransformationMessage(`Successfully transformed data for ${students.length} students.`, 'success');
        
      } catch (error) {
        console.error('Transformation error:', error);
        showTransformationMessage(`Transformation failed: ${error.message}`, 'error');
      }
    }

    function calculateMetrics(transformedYs) {
      const allValues = transformedYs.flat().filter(v => !isNaN(v));
      
      if (allValues.length === 0) {
        return {
          totalPoints: 0,
          averageValue: 0,
          maxValue: 0,
          minValue: 0,
          standardDeviation: 0
        };
      }

      const sum = allValues.reduce((a, b) => a + b, 0);
      const avg = sum / allValues.length;
      const max = Math.max(...allValues);
      const min = Math.min(...allValues);
      
      const variance = allValues.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / allValues.length;
      const stdDev = Math.sqrt(variance);

      return {
        totalPoints: allValues.length,
        averageValue: avg.toFixed(3),
        maxValue: max.toFixed(3),
        minValue: min.toFixed(3),
        standardDeviation: stdDev.toFixed(3)
      };
    }

    function updatePlotWithTransformation(xs, students, transformedYs, yAxisLabel) {
      const plotEl = document.getElementById('plot');
      plotEl.innerHTML = '';
      
      const colors = [
        '#00f5d4', '#f15bb5', '#fee440', '#00bbf9', '#9b5de5',
        '#ef476f', '#06d6a0', '#ffd166', '#118ab2', '#073b4c',
      ];
      
      const series = [
        { label: 'iteration' },
        ...students.map((sid, i) => ({ 
          label: `${sid} (transformed)`, 
          stroke: colors[i % colors.length], 
          width: 2, 
          spanGaps: true 
        }))
      ];
      
      const data = [xs, ...transformedYs];
      const opts = {
        title: `Transformed Data - ${yAxisLabel}`,
        width: plotEl.clientWidth,
        height: 420,
        series,
        axes: [
          { scale: 'x', label: 'Iteration Number', stroke: '#00f5d4', grid: { show: true } },
          { scale: 'y', label: yAxisLabel, stroke: '#00f5d4', grid: { show: true } },
        ],
      };
      
      if (currentPlot) {
        currentPlot.destroy();
      }
      currentPlot = new uPlot(opts, data, plotEl);
      renderLegend(students, colors);
    }

    function showResults(metrics) {
      const resultsPanel = document.getElementById('resultsPanel');
      const metricGrid = document.getElementById('metricGrid');
      
      metricGrid.innerHTML = `
        <div class="metric-card">
          <div class="metric-value">${metrics.totalPoints}</div>
          <div class="metric-label">Total Points</div>
        </div>
        <div class="metric-card">
          <div class="metric-value">${metrics.averageValue}</div>
          <div class="metric-label">Average</div>
        </div>
        <div class="metric-card">
          <div class="metric-value">${metrics.maxValue}</div>
          <div class="metric-label">Maximum</div>
        </div>
        <div class="metric-card">
          <div class="metric-value">${metrics.minValue}</div>
          <div class="metric-label">Minimum</div>
        </div>
        <div class="metric-card">
          <div class="metric-value">${metrics.standardDeviation}</div>
          <div class="metric-label">Std Dev</div>
        </div>
      `;
      
      resultsPanel.style.display = 'block';
    }

    function showTransformationMessage(message, type) {
      const messageEl = document.getElementById('transformationMessage');
      messageEl.innerHTML = `<div class="${type}-message">${message}</div>`;
    }

    function resetTransformation() {
      if (currentLogs.length > 0) {
        const sSel = document.getElementById('studentSelect');
        const eSel = document.getElementById('expSelect');
        buildAndRender(currentLogs, sSel.value, eSel.value);
      }
      document.getElementById('resultsPanel').style.display = 'none';
      document.getElementById('transformationMessage').innerHTML = '';
    }

    async function main() {
      const logs = await fetchLogs();
      if (!logs) return;

      const sSel = document.getElementById('studentSelect');
      const eSel = document.getElementById('expSelect');

      let opts = await fetchOptions();
      let students = opts && Array.isArray(opts.students) ? opts.students : uniqueSorted(logs.map(l => l.student_id).filter(Boolean));
      let experiments = opts && Array.isArray(opts.experiments) ? opts.experiments : uniqueSorted(logs.map(l => l.experiment_name).filter(Boolean));

      const savedSid = localStorage.getItem('viz.sid') || '';
      const savedExp = localStorage.getItem('viz.exp') || '';
      const initSid = QS_SID || savedSid;
      const initExp = QS_EXP || savedExp;

      populateSelect(sSel, students, 'All students');
      populateSelect(eSel, experiments, 'All experiments');

      if (initSid) sSel.value = initSid;
      if (initExp) eSel.value = initExp;

      function rerender() {
        localStorage.setItem('viz.sid', sSel.value);
        localStorage.setItem('viz.exp', eSel.value);
        buildAndRender(logs, sSel.value, eSel.value);
        document.getElementById('resultsPanel').style.display = 'none';
        document.getElementById('transformationMessage').innerHTML = '';
      }

      sSel.addEventListener('change', rerender);
      eSel.addEventListener('change', rerender);

      // Add event listeners for transformation
      document.getElementById('transformBtn').addEventListener('click', applyTransformation);
      document.getElementById('resetBtn').addEventListener('click', resetTransformation);

      // Initial render
      rerender();
    }

    document.addEventListener('DOMContentLoaded', main);
  </script>
</body>
</html>
